<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>寒霜问剑 · Rogue-lite</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>
<header>
    <h1>寒霜问剑（暖雪风格肉鸽）</h1>
    <p>顶视角闪避 + 斩击的小型肉鸽体验：雪夜地牢里拾遗物、躲袭击、清理敌群。</p>
</header>
<main>
    <a class="nav-back" href="/">← 返回首页</a>
    <section class="panel">
        <div class="layout">
            <div>
                <div class="control-row">
                    <button class="btn" id="run-restart">重新开局 (R)</button>
                    <span class="badge">操作：WASD 移动 · J/点击 斩击 · 空格 冲刺</span>
                </div>
                <div class="canvas-frame">
                    <canvas id="dungeon" width="624" height="384"></canvas>
                </div>
                <div class="hint">提示：冲刺可穿越敌人并短暂无敌。拾取遗物会强化斩击、冷却或回复生命。</div>
            </div>
            <div class="panel">
                <div class="stat">击败：<span class="value" id="stat-kills">0</span></div>
                <div class="stat">生命：<span class="value" id="stat-hp">0</span></div>
                <div class="stat">冲刺冷却：<span class="value" id="stat-dash">0s</span></div>
                <div class="separator"></div>
                <h3 style="margin:8px 0 6px;">遗物</h3>
                <ul id="relic-list" style="list-style:none;padding:0;margin:0;color:var(--muted);"></ul>
            </div>
        </div>
    </section>
</main>
<script>
(() => {
    const canvas = document.getElementById('dungeon');
    const ctx = canvas.getContext('2d');
    const ui = {
        kills: document.getElementById('stat-kills'),
        hp: document.getElementById('stat-hp'),
        dash: document.getElementById('stat-dash'),
        relics: document.getElementById('relic-list'),
    };

    const tile = 24;
    const cols = canvas.width / tile;
    const rows = canvas.height / tile;
    const keys = {};

    const relicPool = [
        { id: 'steel', name: '寒钢碎刃', desc: '斩击伤害 +0.5，削铁如泥。', apply: (p) => p.damage += 0.5 },
        { id: 'wind', name: '风痕符', desc: '冲刺冷却 -30%，更频繁地穿梭。', apply: (p) => p.dashCooldown *= 0.7 },
        { id: 'ember', name: '余烬庇佑', desc: '移速 +10%，更易风筝敌人。', apply: (p) => p.speed *= 1.1 },
        { id: 'lotus', name: '雪藏花瓣', desc: '立即回复 1 生命，并将上限 +1。', apply: (p) => { p.maxHp += 1; p.hp = Math.min(p.maxHp, p.hp + 1); } },
    ];

    const state = {
        map: [],
        player: {},
        enemies: [],
        relics: [],
        particles: [],
        kills: 0,
        lastFrame: 0,
        over: false,
    };

    const randInt = (max) => Math.floor(Math.random() * max);

    const buildMap = () => {
        const grid = Array.from({ length: rows }, () => Array(cols).fill(0));
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (y === 0 || y === rows - 1 || x === 0 || x === cols - 1) {
                    grid[y][x] = 1;
                } else if (Math.random() < 0.08 && Math.abs(x - 3) > 2 && Math.abs(y - 3) > 2) {
                    grid[y][x] = 1;
                }
            }
        }
        return grid;
    };

    const isWall = (x, y) => {
        const cx = Math.floor(x / tile);
        const cy = Math.floor(y / tile);
        return cx < 0 || cy < 0 || cx >= cols || cy >= rows || state.map[cy][cx] === 1;
    };

    const placeAtFloor = () => {
        let x, y;
        do {
            x = randInt(cols);
            y = randInt(rows);
        } while (state.map[y][x] === 1 || (x < 6 && y < 6));
        return { x: x * tile + tile / 2, y: y * tile + tile / 2 };
    };

    const createPlayer = () => ({
        x: tile * 2.5,
        y: tile * 2.5,
        radius: 10,
        speed: 140,
        hp: 5,
        maxHp: 5,
        damage: 1,
        dashCooldown: 2.2,
        dashTimer: 0,
        dashActive: 0,
        invuln: 0,
        facing: { x: 1, y: 0 },
        slashTimer: 0,
        slashCooldown: 0,
    });

    const spawnEnemy = () => {
        const pos = placeAtFloor();
        state.enemies.push({
            x: pos.x,
            y: pos.y,
            radius: 11,
            hp: 2,
            speed: 65 + Math.random() * 18,
            wander: Math.random() * Math.PI * 2,
            hitFlash: 0,
        });
    };

    const spawnRelics = () => {
        const pool = [...relicPool].sort(() => Math.random() - 0.5).slice(0, 3);
        state.relics = pool.map((r) => ({ ...r, ...placeAtFloor(), picked: false }));
    };

    const reset = () => {
        state.map = buildMap();
        state.player = createPlayer();
        state.enemies = [];
        state.relics = [];
        state.kills = 0;
        state.over = false;
        for (let i = 0; i < 6; i++) spawnEnemy();
        spawnRelics();
        state.lastFrame = performance.now();
        requestAnimationFrame(loop);
    };

    const drawMap = () => {
        ctx.fillStyle = '#0b0f1c';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (state.map[y][x] === 1) {
                    ctx.fillStyle = '#101624';
                    ctx.fillRect(x * tile, y * tile, tile, tile);
                    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                    ctx.strokeRect(x * tile + 0.5, y * tile + 0.5, tile - 1, tile - 1);
                }
            }
        }
    };

    const drawPlayer = () => {
        const p = state.player;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.fillStyle = p.invuln > 0 ? 'rgba(34, 211, 238, 0.7)' : '#4ade80';
        ctx.beginPath();
        ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(p.facing.x * (p.radius + 6), p.facing.y * (p.radius + 6));
        ctx.stroke();
        ctx.restore();

        if (p.slashTimer > 0) {
            ctx.strokeStyle = 'rgba(255,255,255,0.55)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            const angle = Math.atan2(p.facing.y, p.facing.x);
            const sweep = 0.9;
            ctx.arc(p.x, p.y, 44, angle - sweep, angle + sweep);
            ctx.stroke();
        }
    };

    const drawEnemies = () => {
        state.enemies.forEach((e) => {
            ctx.fillStyle = e.hitFlash > 0 ? '#f87171' : '#c084fc';
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    };

    const drawRelics = () => {
        state.relics.forEach((r) => {
            if (r.picked) return;
            ctx.fillStyle = 'rgba(250, 204, 21, 0.9)';
            ctx.beginPath();
            ctx.arc(r.x, r.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fef08a';
            ctx.stroke();
        });
    };

    const drawUI = () => {
        const p = state.player;
        ui.kills.textContent = state.kills;
        ui.hp.textContent = `${p.hp.toFixed(0)} / ${p.maxHp}`;
        ui.dash.textContent = `${Math.max(0, p.dashTimer).toFixed(1)}s`;
        ui.relics.innerHTML = '';
        state.relics.filter(r => r.picked).forEach(r => {
            const li = document.createElement('li');
            li.textContent = `${r.name} — ${r.desc}`;
            ui.relics.appendChild(li);
        });
    };

    const circleCollides = (x, y, radius) => {
        const checkPoints = [
            [x + radius, y], [x - radius, y], [x, y + radius], [x, y - radius]
        ];
        return checkPoints.some(([cx, cy]) => isWall(cx, cy));
    };

    const moveEntity = (entity, dx, dy) => {
        const nx = entity.x + dx;
        const ny = entity.y + dy;
        if (!circleCollides(nx, entity.y, entity.radius)) entity.x = nx;
        if (!circleCollides(entity.x, ny, entity.radius)) entity.y = ny;
    };

    const tryDash = (p) => {
        if (p.dashTimer > 0) return;
        const dirLen = Math.hypot(p.facing.x, p.facing.y) || 1;
        p.dashActive = 0.18;
        p.dashTimer = p.dashCooldown;
        p.invuln = 0.3;
        p.dashVec = { x: p.facing.x / dirLen, y: p.facing.y / dirLen };
    };

    const slash = (p) => {
        if (p.slashCooldown > 0) return;
       p.slashTimer = 0.2;
       p.slashCooldown = 0.45;
       const reach = 46;
       const dirLen = Math.hypot(p.facing.x, p.facing.y) || 1;
       const dir = { x: p.facing.x / dirLen, y: p.facing.y / dirLen };
       state.enemies.forEach((e) => {
           const dx = e.x - p.x;
           const dy = e.y - p.y;
            const dist = Math.max(0.0001, Math.hypot(dx, dy));
            if (dist < reach + e.radius) {
                const dot = (dx / dist) * dir.x + (dy / dist) * dir.y;
                if (dot > 0.2) {
                    e.hp -= p.damage;
                    e.hitFlash = 0.18;
                }
            }
        });
        state.enemies = state.enemies.filter((e) => {
            if (e.hp <= 0) {
                state.kills += 1;
                if (state.enemies.length < 8) spawnEnemy();
                return false;
            }
            return true;
        });
    };

    const handleInput = (dt) => {
        const p = state.player;
        const mv = { x: 0, y: 0 };
        if (keys['w']) mv.y -= 1;
        if (keys['s']) mv.y += 1;
        if (keys['a']) mv.x -= 1;
        if (keys['d']) mv.x += 1;
        if (mv.x || mv.y) {
            const len = Math.hypot(mv.x, mv.y) || 1;
            mv.x /= len; mv.y /= len;
            p.facing = { ...mv };
        }
        if (keys[' '] && !state.over) tryDash(p);

        const speed = p.dashActive > 0 ? p.speed * 3.2 : p.speed;
        moveEntity(p, mv.x * speed * dt, mv.y * speed * dt);
    };

    const updatePlayer = (dt) => {
        const p = state.player;
        p.invuln = Math.max(0, p.invuln - dt);
        p.dashTimer = Math.max(0, p.dashTimer - dt);
        p.dashActive = Math.max(0, p.dashActive - dt);
        p.slashTimer = Math.max(0, p.slashTimer - dt);
        p.slashCooldown = Math.max(0, p.slashCooldown - dt);
        if (p.dashActive > 0 && p.dashVec) {
            moveEntity(p, p.dashVec.x * p.speed * 2.6 * dt, p.dashVec.y * p.speed * 2.6 * dt);
        }
    };

    const updateEnemies = (dt) => {
        const p = state.player;
        state.enemies.forEach((e) => {
            e.hitFlash = Math.max(0, e.hitFlash - dt);
            const dx = p.x - e.x;
            const dy = p.y - e.y;
            const dist = Math.hypot(dx, dy) || 1;
            const dir = { x: dx / dist, y: dy / dist };
            const speed = e.speed * (dist > 160 ? 0.75 : 1);
            moveEntity(e, dir.x * speed * dt, dir.y * speed * dt);
            if (dist < e.radius + p.radius + 2 && p.invuln <= 0) {
                p.hp -= 1;
                p.invuln = 0.8;
                if (p.hp <= 0) state.over = true;
            }
        });
    };

    const checkRelics = () => {
        const p = state.player;
        state.relics.forEach((r) => {
            if (r.picked) return;
            const dist = Math.hypot(p.x - r.x, p.y - r.y);
            if (dist < 26) {
                r.picked = true;
                r.apply(p);
            }
        });
    };

    const drawOverlay = () => {
        if (!state.over) return;
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '20px "Segoe UI"';
        ctx.textAlign = 'center';
        ctx.fillText('你倒在雪夜中 - 按 R 重新开始', canvas.width / 2, canvas.height / 2);
    };

    const loop = (ts) => {
        const dt = Math.min(0.05, (ts - state.lastFrame) / 1000);
        state.lastFrame = ts;
        drawMap();
        if (!state.over) {
            handleInput(dt);
            updatePlayer(dt);
            updateEnemies(dt);
            checkRelics();
        }
        drawRelics();
        drawEnemies();
        drawPlayer();
        drawOverlay();
        drawUI();
        if (!state.over) requestAnimationFrame(loop);
    };

    document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === 'j' || e.key === 'J') slash(state.player);
        if (e.key === 'r' || e.key === 'R') reset();
    });
    document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
    canvas.addEventListener('mousedown', () => slash(state.player));
    document.getElementById('run-restart').addEventListener('click', reset);

    reset();
})();
</script>
</body>
</html>
